(define (choose-type type1 type2)
  (let ((type-list (list 'complex 'rational 'scheme-number)))
    (define next-type (type1 type2 remaining-types)
      (cond ((null? remaining-types) (error "no common type"))
            ((or (eq? type1 (car remaining-types))
              (eq? type2 (car remaining-types)))
            (car remaining-types))
            (else (next-type type1 type2 (cdr remaining-types)))))
  (next-type type1 type2 type-list)))

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
        (apply-proc (map contents args))
        (if (= (length args) 2)
          (let ((type1 (car type-tags))
                (type2 (cadr type-tags))
                (a1 (car args))
                (a2 (cadr args)))
            (let ((new-type (choose-type type1 type2))
                  (t1->new (get-coercion type1 new-type))
                  (t2->new (get-coercion type2 new-type)))
              (cond ((and t1->new t2->new)
                      (apply-generic op (t1->new a1) (t2->new a2)))
                    (else
                      (error "No method for these types"))))))
        (error "No method for these types")))))

